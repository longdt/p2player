This makes slow peers pick blocks from the same piece, and fast peers pick from the same piece, and hence decreasing the likelihood of slow peers blocking the completion of pieces.
TODO:
F	+need api implement binding api get_download_queue() (done)
NNN	+api reset piece deadline binding (important) (done)
		try re-send request if time-out (important)
F	_fix bug upnp (http response gzip encoding) (done)
		fixed on version 0.15.10
SF	change: void torrent::remove_time_critical_piece(int piece, bool finished) {} (done) need tunning
N	peer_connection::snub_peer
F	change alert fix bug save_resume_data_alert (done)
F	fix getFirstPieceIncompleted() implement lock (important) (done)
F	change the way store map torrent-id torrent_handle by using hash (important) (done)
F	remove torrent and delete data	(done) (need modify library boost compiled with exception why libtorrent build with boost_no_exception)
		wordaround: build with boost exception or change code add try catch on method delete_on_file
F	change api addTorrent using param automanaged instead isSequence	(done)
N	throws exception on invalid torrent handle
F	throws exception when set deadline/priority out of range (done)
		ignore when piecedIdx out of range
F	implement binding api getTorrentPieceNums (done)
N	change function HandleAlert()
N	add api read alert
F	random listen port (important) (done)
N	stream folder torrent(important)
N	optimize httpd when transfer data


			if ( content_stream_bps_min == 0 ){
			
					// hack in some test values for torrents that don't have a bps in them yet
				
				long	size = torrent.getSize();
				
				if ( size < 200*1024*1024 ){
				
					content_stream_bps_min = 30*1024;
					
				}else if ( size < 1000*1024*1024L ){
					
					content_stream_bps_min = 200*1024;
					
				}else{

					content_stream_bps_min = 400*1024;
				}
			}
			
					// bump it up by a bit to be conservative to deal with fluctuations, discards etc.
				
			content_stream_bps_min += content_stream_bps_min / content_stream_bps_min_increase_ratio;
			
			content_stream_bps_max = content_stream_bps_min + ( content_stream_bps_min / content_stream_bps_max_increase_ratio );
			